#pragma once

#include "dd/ComplexNumbers.hpp"
#include "dd/MemoryManager.hpp"
#include "dd/Node.hpp"
#include "dd/RealNumber.hpp"
#include "dd/RealNumberUniqueTable.hpp"

#include <complex>
#include <random>
#include <utility>

namespace dd {
class StateGenerator {
public:
  /**
   * @brief Initializes the StateGenerator object with a given seed
   * @param s the seed to use for the random number generator
   * @details If the seed is 0, a random seed is generated using
   * std::random_device
   */
  StateGenerator(std::size_t s = 0U);

  ~StateGenerator() = default;

  /**
   * @brief Randomly create a vector DD with a certain number of nodes per level
   * @details This function randomly creates a vector DD with a particular
   * structure. To this end, it creates a certain (variable) number of nodes per
   * level, connects them to nodes at the next level, and then repeats this
   * process until the desired number of levels is reached. Since all nodes are
   * normalized by construction, no normalization is necessary.
   * @param levels the number of levels in the vector DD
   * @param nodesPerLevel the number of nodes per level
   * @return a random vector DD
   */
  vEdge generateRandomVectorDD(std::size_t levels,
                               const std::vector<std::size_t>& nodesPerLevel);

private:
  /**
   * @brief Returns a random complex number on the unit circle
   * @return a random complex number on the unit circle
   */
  std::complex<double> getRandomComplexOnUnitCircle();

  /**
   * @brief Returns a random single-qubit state
   * @return a random single-qubit state
   */
  std::pair<std::complex<double>, std::complex<double>>
  getRandomSingleQubitState();

  /**
   * @brief Generates a random, normalized vector DD node
   * @details This simply generates a random single-qubit state and creates a
   * DD vector node from it. The node's successors are unspecified. Due to the
   * way the numbers are generated, no normalization is necessary.
   * @param qubit the qubit index of the node
   * @return a random DD vector node
   */
  vNode* generateRandomNode(Qubit qubit);

  /**
   * @brief Randomly connect a node to a list of potential successors
   * @details This function randomly connects a node which is assumed to have
   * been generated by generateRandomNode to a list of potential successors that
   * have also been generated by generateRandomNode. Since every nodes is
   * normalized, no normalization is necessary. The function makes sure that, if
   * it is called enough times, it will eventually use every successor at least
   * once.
   * @param node the node to connect
   * @param successors the list of potential successors
   * @param used a list of booleans indicating whether a successor has already
   * been used
   */
  void connectNodeToRandomSuccessors(vNode* node,
                                     std::vector<vNode*>& successors,
                                     std::vector<bool>& used);

  std::size_t seed{};
  std::mt19937_64 generator;
  std::uniform_real_distribution<double> angleDistribution;

  MemoryManager<vNode> vNodeMemoryManager{};
  MemoryManager<RealNumber> realNumberMemoryManager{};
  RealNumberUniqueTable realNumberUniqueTable{realNumberMemoryManager};
  ComplexNumbers cn{realNumberUniqueTable, realNumberMemoryManager};
};
} // namespace dd
